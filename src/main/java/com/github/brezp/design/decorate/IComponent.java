package com.github.brezp.design.decorate;

/**
 * 感觉装饰器模式有点像俄罗斯套娃、某众汽⻋ ) ，⽽装饰器的核⼼就是再不改原有类的基础上
 * 给类新增功能。不改变原有类，可能有的⼩伙伴会想到继承、AOP切⾯，当然这些⽅式都可以实现，但
 * 是使⽤装饰器模式会是另外⼀种思路更为灵活，可以避免继承导致的⼦类过多，也可以避免AOP带来的
 * 复杂性。
 * 你熟悉的场景很多⽤到装饰器模式
 * new BufferedReader(new FileReader("")); ，这段代码你是否熟悉，相信学习java开发到字节
 * 流、字符流、⽂件流的内容时都⻅到了这样的代码，⼀层嵌套⼀层，⼀层嵌套⼀层，字节流转字符流等
 * 等，⽽这样⽅式的使⽤就是装饰器模式的⼀种体现。
 *
 *
 * 装饰器主要解决的是直接继承下因功能的不断横向扩展导致⼦类膨胀的问题，⽽是⽤装饰器模式后就会
 * ⽐直接继承显得更加灵活同时这样也就不再需要考虑⼦类的维护。
 * 在装饰器模式中有四个⽐较᯿要点抽象出来的点；
 * 1. 抽象构件⻆⾊(Component) - 定义抽象接⼝
 * 2. 具体构件⻆⾊(ConcreteComponent) - 实现抽象接⼝，可以是⼀组
 * 3. 装饰⻆⾊(Decorator) - 定义抽象类并继承接⼝中的⽅法，保证⼀致性
 * 4. 具体装饰⻆⾊(ConcreteDecorator) - 扩展装饰具体的实现逻辑
 * 通过以上这四项来实现装饰器模式，主要核⼼内容会体现在抽象类的定义和实现上
 *
 *
 * @author brezp
 */
public interface IComponent {
}
